// cmd/cli/output.go
package main

import (
    "encoding/json"
    "fmt"
    "os"
    //"strings"
    
    "github.com/olekukonko/tablewriter"
    "gopkg.in/yaml.v3"
)

func outputResults(records []map[string]interface{}) {
    switch config.Output {
    case "json":
        outputAsJSON(records)
    case "yaml":
        outputAsYAML(records)
    case "ipset":
        outputAsIPSet(records)
    case "table":
        fallthrough
    default:
        outputAsTable(records)
    }
}

func outputAsJSON(data interface{}) {
    jsonData, err := json.MarshalIndent(data, "", "  ")
    if err != nil {
        fmt.Printf("Error marshaling JSON: %v\n", err)
        return
    }
    fmt.Println(string(jsonData))
}

func outputAsYAML(data interface{}) {
    yamlData, err := yaml.Marshal(data)
    if err != nil {
        fmt.Printf("Error marshaling YAML: %v\n", err)
        return
    }
    fmt.Println(string(yamlData))
}

func outputAsTable(records []map[string]interface{}) {
    if len(records) == 0 {
        fmt.Println("No records found")
        return
    }
    
    table := tablewriter.NewWriter(os.Stdout)
    table.SetHeader([]string{"ID", "Set Name", "IP", "CIDR", "Port", "Protocol", "Description", "Context", "Created"})
    table.SetBorder(false)
    table.SetRowLine(true)
    table.SetColumnSeparator("│")
    table.SetHeaderColor(
        tablewriter.Colors{tablewriter.Bold, tablewriter.FgCyanColor},
        tablewriter.Colors{tablewriter.Bold, tablewriter.FgCyanColor},
        tablewriter.Colors{tablewriter.Bold, tablewriter.FgCyanColor},
        tablewriter.Colors{tablewriter.Bold, tablewriter.FgCyanColor},
        tablewriter.Colors{tablewriter.Bold, tablewriter.FgCyanColor},
        tablewriter.Colors{tablewriter.Bold, tablewriter.FgCyanColor},
        tablewriter.Colors{tablewriter.Bold, tablewriter.FgCyanColor},
        tablewriter.Colors{tablewriter.Bold, tablewriter.FgCyanColor},
        tablewriter.Colors{tablewriter.Bold, tablewriter.FgCyanColor},
    )
    
    for _, record := range records {
        table.Append([]string{
            fmt.Sprintf("%v", record["id"]),
            fmt.Sprintf("%v", record["set_name"]),
            fmt.Sprintf("%v", record["ip"]),
            fmt.Sprintf("%v", record["cidr"]),
            fmt.Sprintf("%v", record["port"]),
            fmt.Sprintf("%v", record["protocol"]),
            truncateString(fmt.Sprintf("%v", record["description"]), 20),
            truncateString(fmt.Sprintf("%v", record["context"]), 20),
            formatDate(record["created_at"]),
        })
    }
    
    table.Render()
}

func outputAsIPSet(records []map[string]interface{}) {
    if len(records) == 0 {
        fmt.Println("No records to export")
        return
    }
    
    fmt.Println("#!/bin/bash")
    fmt.Println("# IPSet rules generated by ipset-cli")
    fmt.Println()
    
    // Группируем по set_name
    setMap := make(map[string][]map[string]interface{})
    for _, record := range records {
        setName, _ := record["set_name"].(string)
        if setName == "" {
            setName = "default"
        }
        setMap[setName] = append(setMap[setName], record)
    }
    
    for setName, setRecords := range setMap {
        // Определяем тип сета
        setType := "hash:ip"
        if len(setRecords) > 0 {
            if st, ok := setRecords[0]["set_type"].(string); ok && st != "" {
                setType = st
            }
        }
        
        fmt.Printf("# Create set: %s\n", setName)
        fmt.Printf("ipset create %s %s -exist\n", setName, setType)
        fmt.Println()
        
        for _, record := range setRecords {
            ip := fmt.Sprintf("%v", record["ip"])
            cidr := fmt.Sprintf("%v", record["cidr"])
            port := fmt.Sprintf("%v", record["port"])
            protocol := fmt.Sprintf("%v", record["protocol"])
            desc := fmt.Sprintf("%v", record["description"])
            id := fmt.Sprintf("%v", record["id"])
            
            // Формируем IP/CIDR
            entry := ip
            if cidr != "" && cidr != "<nil>" && cidr != "0" && cidr != "32" {
                entry = ip + "/" + cidr
            }
            
            if port != "" && port != "<nil>" && port != "0" {
                if protocol != "" && protocol != "<nil>" {
                    entry += fmt.Sprintf(",%s:%s", protocol, port)
                } else {
                    entry += fmt.Sprintf(",%s", port)
                }
            }
            
            comment := fmt.Sprintf("# Rule ID: %s", id)
            if desc != "" && desc != "<nil>" {
                comment += fmt.Sprintf(" - %s", desc)
            }
            
            fmt.Println(comment)
            fmt.Printf("ipset add %s %s -exist\n", setName, entry)
        }
        fmt.Println()
    }
    
    fmt.Println("# Example iptables rules:")
    for setName := range setMap {
        fmt.Printf("# iptables -A INPUT -m set --match-set %s src -j ACCEPT\n", setName)
    }
}

func truncateString(s string, maxLen int) string {
    if len(s) <= maxLen {
        return s
    }
    return s[:maxLen-3] + "..."
}

func formatDate(date interface{}) string {
    if date == nil {
        return ""
    }
    
    dateStr, ok := date.(string)
    if !ok {
        return ""
    }
    
    if len(dateStr) > 10 {
        return dateStr[:10]
    }
    return dateStr
}